/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed
 * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
 * OR CONDITIONS OF ANY KIND, either express or implied. See the License for
 * the specific language governing permissions and limitations under the
 * License.
 */
package org.amplafi.flow.translator;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.amplafi.flow.DataClassDefinition;
import org.amplafi.flow.FlowException;
import org.amplafi.flow.FlowPropertyDefinition;
import org.amplafi.flow.FlowRenderer;
import org.amplafi.flow.FlowTranslatorResolver;
import org.amplafi.flow.flowproperty.FlowPropertyProvider;
import org.amplafi.flow.validation.FlowValidationException;
import org.apache.commons.collections.list.SetUniqueList;

import com.sworddance.util.ApplicationIllegalArgumentException;

import static com.sworddance.util.CUtilities.*;

/**
 *
 * @author patmoore
 *
 * @param <T> class being translated.
 */
public abstract class AbstractFlowTranslator<T> implements FlowTranslator<T> {
    private FlowTranslatorResolver flowTranslatorResolver;
    protected List<Class<?>> serializedFormClasses = SetUniqueList.decorate(new ArrayList<Class<?>>());
    private List<Class<?>> deserializedFormClasses = SetUniqueList.decorate(new ArrayList<Class<?>>());
    private boolean flowTranslatorJsonRenderer;
    private FlowRenderer<T> flowRenderer;

//    @SuppressWarnings("unchecked")
//    protected static final FlowTranslator<CharSequence> DEFAULT_FLOW_TRANSLATOR = CharSequenceFlowTranslator.INSTANCE;

    @SuppressWarnings("unchecked")
    protected AbstractFlowTranslator(AbstractFlowTranslator<?> flowTranslator) {
        this.flowTranslatorResolver = flowTranslator.getFlowTranslatorResolver();
        this.deserializedFormClasses.addAll(flowTranslator.deserializedFormClasses);
        this.serializedFormClasses.addAll(flowTranslator.serializedFormClasses);
        this.flowTranslatorJsonRenderer = flowTranslator.flowTranslatorJsonRenderer;
        this.flowRenderer = (FlowRenderer<T>) flowTranslator.flowRenderer;
    }
    protected AbstractFlowTranslator() {
        serializedFormClasses.add(CharSequence.class);
        serializedFormClasses.add(String.class);
        this.flowTranslatorJsonRenderer = FlowRenderer.class.isAssignableFrom(this.getClass());
    }

    /**
     * @param flowRenderer
     */
    public AbstractFlowTranslator(FlowRenderer<T> flowRenderer) {
        this();
        this.flowRenderer = flowRenderer;
    }

    /**
     * @see org.amplafi.flow.translator.FlowTranslator#deserialize(FlowPropertyProvider , org.amplafi.flow.FlowPropertyDefinition , org.amplafi.flow.DataClassDefinition, java.lang.Object)
     */
    @SuppressWarnings("unchecked")
    @Override
    public T deserialize(FlowPropertyProvider flowPropertyProvider, FlowPropertyDefinition flowPropertyDefinition, DataClassDefinition dataClassDefinition, Object serializedObject) throws FlowException {
        if ( serializedObject == null ) {
            return null;
        } else if ( isDeserializedForm(serializedObject.getClass())) {
            return (T) serializedObject;
        } else {
            return doDeserialize(flowPropertyProvider, flowPropertyDefinition, dataClassDefinition, serializedObject);
        }
    }

    @Override
    public final <W extends SerializationWriter> W serialize(FlowPropertyDefinition flowPropertyDefinition, DataClassDefinition dataClassDefinition, W outputWriter, T object) {
        W jsonWriter;
        if ( outputWriter == null ) {
            jsonWriter = getSerializationWriter();
        } else {
            jsonWriter = outputWriter;
        }

        if ( object == null ) {
            // if jsonWriter is expecting a value ( because it just had a key set ) then we need to serialize a null.
            // TODO: investigate serializing a null.
            return jsonWriter;
        } else if ( this.isSerializedForm(object.getClass())) {
            // already in a serialized form? (we hope )
            return (W) jsonWriter.value(object);
        } else {
            return (W) doSerialize(flowPropertyDefinition, dataClassDefinition, (SerializationWriter) jsonWriter, object);
        }
    }
    /**
     * @return a JsonWriter (generated by {@link org.amplafi.flow.FlowTranslatorResolver} usually )
     */
    protected <W extends SerializationWriter> W getSerializationWriter() {
        return (W) flowTranslatorResolver.getSerializationWriter();
    }
    /**
     * @param jsonWriter
     * @param object
     * @return jsonWriter
     */
    @SuppressWarnings("unused")
    protected <W extends SerializationWriter> W doSerialize(FlowPropertyDefinition flowPropertyDefinition, DataClassDefinition dataClassDefinition, W serializationWriter, T object) {
        toSerialization(serializationWriter, object);
        return serializationWriter;
    }

    @SuppressWarnings({"unused","unchecked"})
    protected T doDeserialize(FlowPropertyProvider flowPropertyProvider, FlowPropertyDefinition flowPropertyDefinition, DataClassDefinition dataClassDefinition, Object serializedObject) throws FlowValidationException {
        return (T) fromSerialization(serializedObject);
    }

    @SuppressWarnings("unused")
    public boolean isSerializable(FlowPropertyDefinition flowPropertyDefinition, DataClassDefinition dataClassDefinition, Object value) {
        if ( value == null ) {
            return true;
        } else {
            return isAssignableFrom(value.getClass());
        }
    }
    @Override
    public boolean isAssignableFrom(Class<?> differentClass) {
        if (getTranslatedClass().isAssignableFrom(differentClass)) {
            return true;
        } else {
            for(Class<?> clazz: this.serializedFormClasses) {
                if (clazz.isAssignableFrom(differentClass) ) {
                    return true;
                }
            }
            for(Class<?> clazz: this.getDeserializedFormClasses()) {
                if (clazz.isAssignableFrom(differentClass) ) {
                    return true;
                }
            }
            return false;
        }
    }

    @Override
    public boolean isDeserializable(FlowPropertyDefinition flowPropertyDefinition, DataClassDefinition dataClassDefinition, Object value) {
        if ( value == null ) {
            return true;
        } else {
            return isAssignableFrom(value.getClass());
        }
    }

    @Override
    public T getDefaultObject(FlowPropertyProvider flowPropertyProvider) {
        return null;
    }
    protected void addSerializedFormClasses(Class<?>... clazz) {
        this.serializedFormClasses.addAll(Arrays.asList(clazz));
    }
    protected void addDeserializedFormClasses(Class<?>... clazz) {
        Collections.addAll(this.deserializedFormClasses,clazz);
    }
    @Override
    public boolean isDeserializedForm(Class<?> clazz) {
        return clazz == getTranslatedClass() || deserializedFormClasses.contains(clazz);
    }
    public boolean isSerializedForm(Class<?> clazz) {
        return serializedFormClasses.contains(clazz);
    }
    public void setDeserializedFormClasses(List<Class<?>> deserializedFormClasses) {
        this.deserializedFormClasses.clear();
        if ( isNotEmpty(deserializedFormClasses)) {
            this.deserializedFormClasses.addAll(deserializedFormClasses);
        }
    }

    @Override
    public List<Class<?>> getDeserializedFormClasses() {
        if ( !deserializedFormClasses.contains(getTranslatedClass())) {
            deserializedFormClasses.add(getTranslatedClass());
        }
        return deserializedFormClasses;
    }

    /**
     * NOTE: May be overridden!
     * @see org.amplafi.flow.translator.FlowTranslator#getTranslatedClass()
     */
    @Override
    public Class<?> getTranslatedClass() {
        return flowRenderer.getClassToRender();
    }

    /**
     * @param jsonWriter
     * @param object
     * @return TODO
     */
    public <W extends SerializationWriter> W toSerialization(W jsonWriter, T object) {
        ApplicationIllegalArgumentException.valid(this != flowRenderer, this,":infinite loop flowRenderer==this");

        return flowRenderer.toSerialization(jsonWriter, object);
    }

    /**
     * @param <K>
     * @param serializedObject
     * @return the deserialized (from json) value.
     */
    @SuppressWarnings("unchecked")
    public <K> K fromSerialization(Object serializedObject) {
        return (K) flowRenderer.fromSerialization(getTranslatedClass(), serializedObject);
    }

    /**
     * @return the flowRenderer
     */
    @SuppressWarnings("unchecked")
    public FlowRenderer<T> getFlowRenderer() {
        return flowRenderer == null && this.flowTranslatorJsonRenderer? (FlowRenderer<T>)this : flowRenderer ;
    }

    protected void setFlowRenderer(FlowRenderer<T> flowRenderer) {
        this.flowRenderer = flowRenderer;
    }

    /**
     * @param flowTranslatorResolver the flowTranslatorResolver to set
     */
    public void setFlowTranslatorResolver(FlowTranslatorResolver flowTranslatorResolver) {
        this.flowTranslatorResolver = flowTranslatorResolver;
    }

    /**
     * @return the flowTranslatorResolver
     */
    public FlowTranslatorResolver getFlowTranslatorResolver() {
        return flowTranslatorResolver;
    }
}
